/*
 * Simple script to write to (program) Leo2p0/Hera silicon.  
 * Polling to determine if eeprom is not busy is simple repeat of read
 * without 'while'
 * Write to even addresses first and write as a pair.
 *
 * First write to BUCK1_VOUT2
 * Second write to the CRC registers
 *
 * CRC data retreival
 * power up device with enable pulled low
 * account for 'wait for enable sequence'
 * record CRC 1-14
 * change BUCK1_VOUT2
 * record change to CRC1-14
 *
 */
function main() {
    invoke('setUpdateInterval',[-1]);
	// Enable EEPROM program
	write('USER_EE_CTRL_1', 0x00);
    write('USER_EE_CTRL_1', 0x98);
    write('USER_EE_CTRL_1', 0xB8);
    write('USER_EE_CTRL_1', 0x13);
    write('USER_EE_CTRL_1', 0x7D);
	// check mission state
	read('TEST_FFSM_1');
	read('TEST_PFSM_0');
	write('GENERAL_REG_1', 0x05);      // 0x49, 0x18
	//
	write('EEPROM_CONTROL_2', 0x2E);  // updated 04_24_2020
	// check OTA state
	read('TEST_FFSM_1');
	read('TEST_PFSM_0');
    read('USER_EE_CTRL_2');
    write('USER_EE_CTRL_2', 0xC1);
	read('USER_EE_CTRL_2');

    // check OTA state
	read('TEST_FFSM_1');
	read('TEST_PFSM_0');
	
	/*************************************************************************/
	// Read data
	/*
	 *  Write “0x2f” to ... address 0xe1, EEPROM_CONTROL_2
	 *      Set TM_EE_CFG_SINGLE
	 *      LEO has 4 banks
	 *          BANK 0 is the PAGE0-2 information
	 *          BANK 1 is the PAGE3 SRAM address space 0-0xFF
	 *          BANK 2 is the PAGE3 SRAM address space 0x100 to 0x1FF
	 *          BANK 3 is the PAGE 3SRAM address space 0x200 to 0x2FF
	 *      Disable banks '1110b' defined in LEO
	 *
	 *  Write “0x1c” to ... address 0xe2, EEPROM_CONTROL_3
	 *      Address for program and read
	 *
	 *  Write “0x01” to ... address 0xef, EEPROM_CONTROL_16
	 *      TM_EE_CMD_READ
	 */
	//write('EEPROM_CONTROL_2', 0x2E);
	// address
	write('EEPROM_CONTROL_3', 0x1C);
	// read
	write('EEPROM_CONTROL_16', 0x01);

    // check OTA state
	read('TEST_FFSM_1');
	read('TEST_PFSM_0');
	
	let dummy = read('EEPROM_CONTROL_20');
	while(dummy & 0x02)
	{
        dummy = read('EEPROM_CONTROL_20');
	}

	let byteRead1 = read('EEPROM_CONTROL_15');	
	let byteRead2 = read('EEPROM_CONTROL_14');
	let byteRead3 = read('EEPROM_CONTROL_13');
	let byteRead4 = read('EEPROM_CONTROL_12');

    // check OTA state
	read('TEST_FFSM_1');
	read('TEST_PFSM_0');

	/*
     * Change address to 0x1D 
	 */
	write('EEPROM_CONTROL_3', 0x1D);
	write('EEPROM_CONTROL_16', 0x01);	

    dummy = read('EEPROM_CONTROL_20');
	while(dummy & 0x02)
	{
        dummy = read('EEPROM_CONTROL_20');
	}	

	let byteRead5 = read('EEPROM_CONTROL_15');	
	let byteRead6 = read('EEPROM_CONTROL_14');
	let byteRead7 = read('EEPROM_CONTROL_13');
	let byteRead8 = read('EEPROM_CONTROL_12');

    // check OTA state
	read('TEST_FFSM_1');
	read('TEST_PFSM_0');
	
	// Read out CRC content at registes 0xF0 (REGMAP_USER_INCLUDE_PERSIST_CRC16_Low)
    // and 0xF2 (REGMAP_USER_EXCLUDE_PERSIST_CRC16_Low) 0x3C (no change) and 0x3D (bytes 0 and 2)
	// 
	// byte0 -> 0x6D
	// byte2 -> 0x1D
	
	/*
     * Change address to 0x3C 
	 */
	write('EEPROM_CONTROL_3', 0x3C);
	write('EEPROM_CONTROL_16', 0x01);	

    dummy = read('EEPROM_CONTROL_20');
	while(dummy & 0x02)
	{
        dummy = read('EEPROM_CONTROL_20');
	}	

	let byteRead9 = read('EEPROM_CONTROL_15');	
	let byteReadA = read('EEPROM_CONTROL_14');
	let byteReadB = read('EEPROM_CONTROL_13');
	let byteReadC = read('EEPROM_CONTROL_12');

    // check OTA state
	read('TEST_FFSM_1');
	read('TEST_PFSM_0');


	/*
     * Change address to 0x3D 
	 */
	write('EEPROM_CONTROL_3', 0x3D);
	write('EEPROM_CONTROL_16', 0x01);	

    dummy = read('EEPROM_CONTROL_20');
	while(dummy & 0x02)
	{
        dummy = read('EEPROM_CONTROL_20');
	}	

	let byteReadD = read('EEPROM_CONTROL_15');	
	let byteReadE = read('EEPROM_CONTROL_14');
	let byteReadF = read('EEPROM_CONTROL_13');
	let byteRead10 = read('EEPROM_CONTROL_12');	

    // check OTA state
	read('TEST_FFSM_1');
	read('TEST_PFSM_0');

	// BUCK2_VSET2 cannot be '0'
	while(!byteRead5);		
	
	/*************************************************************************/
	// Write data
    // change byteRead3 to new BUCK1_VSET2 voltage  0.79V, 0x35
	// 

	// Bits 0-7
	write('EEPROM_CONTROL_11', byteRead1);
	write('EEPROM_CONTROL_10', byteRead2);
    byteRead3 = 0x35;
	write('EEPROM_CONTROL_9', byteRead3);
	write('EEPROM_CONTROL_8', byteRead4);
	
    write('EEPROM_CONTROL_3', 0x1C);
	write('EEPROM_CONTROL_16', 0x02);	

	dummy = read('EEPROM_CONTROL_20');
	while(dummy & 0x02)
	{
        dummy = read('EEPROM_CONTROL_20');
	}
	
	// check OTA state
	read('TEST_FFSM_1');
	read('TEST_PFSM_0');
	
	write('EEPROM_CONTROL_11', byteRead5);
	write('EEPROM_CONTROL_10', byteRead6);
	write('EEPROM_CONTROL_9', byteRead7);
	write('EEPROM_CONTROL_8', byteRead8);
	
    write('EEPROM_CONTROL_3', 0x1D);
	write('EEPROM_CONTROL_16', 0x02);	

	dummy = read('EEPROM_CONTROL_20');
	while(dummy & 0x02)
	{
        dummy = read('EEPROM_CONTROL_20');
	}
	
	// check OTA state
	read('TEST_FFSM_1');
	read('TEST_PFSM_0');
	
	// Update CRC
	
	write('EEPROM_CONTROL_11', byteRead9);
	write('EEPROM_CONTROL_10', byteReadA);
	write('EEPROM_CONTROL_9', byteReadB);
	write('EEPROM_CONTROL_8', byteReadC);
	
    write('EEPROM_CONTROL_3', 0x3C);
	write('EEPROM_CONTROL_16', 0x02);	

	dummy = read('EEPROM_CONTROL_20');
	while(dummy & 0x02)
	{
        dummy = read('EEPROM_CONTROL_20');
	}
	
	// check OTA state
	read('TEST_FFSM_1');
	read('TEST_PFSM_0');
	
	byteReadD = 0x6D;
	write('EEPROM_CONTROL_11', byteReadD);
	write('EEPROM_CONTROL_10', byteReadE);
	byteReadF = 0x1D;
	write('EEPROM_CONTROL_9', byteReadF);
	write('EEPROM_CONTROL_8', byteRead10);
	
    write('EEPROM_CONTROL_3', 0x3D);
	write('EEPROM_CONTROL_16', 0x02);	

	dummy = read('EEPROM_CONTROL_20');
	while(dummy & 0x02)
	{
        dummy = read('EEPROM_CONTROL_20');
	}
	
	// check OTA state
	read('TEST_FFSM_1');
	read('TEST_PFSM_0');
	
    // exit programming mode
    write('USER_EE_CTRL_1', 0x00);

	// send command to invoke EEPROM update?
	
    invoke('setUpdateInterval',[100]);
}